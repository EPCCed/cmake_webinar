{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CMAKE Tutorial","text":"<p>It is common on High Performance Computing machines to install software packages from source code. Many packages today make use of CMake, an open-source tool that automates the process of building, testing and packaging software.</p> <p>Here we give an introduction to CMake from the point of view of a user attempting to install a CMake package. We will cover configuring, building and installing packages, introduce common good practices and highlight troubleshooting techniques.</p> <p>Additionally, we will give a brief overview of how to develop a CMake package.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>When building a package you often need to configure the build process. You may need to specify which compiler to use or turn on/off some functionalities in the package, specify which libraries to link with and what compiler to use, etc..</p>"},{"location":"configuration/#setting-variables","title":"Setting variables","text":"<p>Packages often define some variables that can be set by the user. Some of these variables are builtin in the CMake framework, while others are created by package developers.</p>"},{"location":"configuration/#listing-variables","title":"Listing variables","text":"<p>You can find a list of all variables, including variables defined by the CMake package and built-in variables by typing</p> <pre><code>cmake ${CMAKE_PACKAGE_DIRECTORY} -LHA\n</code></pre> <p>Here you invoke cmake with the source directory as a first argument and the additional flags:</p> <ul> <li><code>-L</code>: print a list of CMake variables</li> <li><code>-A</code>: print a list of all advanced variables. Variables marked as <code>advanced</code> are hidden by default and usually do not need to be changed by the package user.</li> <li><code>-H</code>: print helper strings for each variable. A helper string is meant to provide a description of the variable.</li> </ul> <p>Alternatively, you can use the interactive tool</p> <pre><code>ccmake ${CMAKE_PACKAGE_DIRECTORY}\n</code></pre> <p>This will open an interactive program from which the user is able to view and modify user-modifiable variables.</p>"},{"location":"configuration/#specifying-variables","title":"Specifying variables","text":"<p>Once you know the name of a variable and which value you want to set it to, you can specify a variable at configure time by adding the argument <code>-DVAR_NAME=${VAR_VALUE}</code></p> <p>For instance, you can configure a project with the variable named <code>VAR_NAME</code> set to <code>${VAR_VALUE}</code> by typing</p> <pre><code>cmake ${CMAKE_PACKAGE_DIRECTORY} -DVAR_NAME=${VAR_VALUE}\n</code></pre>"},{"location":"configuration/#builtin-variables","title":"Builtin variables","text":"<p>Some variables are defined by CMake itself and not by the package developers. Some commonly used CMake variables are</p> <ul> <li>CMAKE_BUILD_TYPE: Can be set to one of <code>Debug</code>, <code>Release</code>, <code>RelWithDebInfo</code> and <code>MinSizeRel</code>. You can use it to turn on optimisation flags (<code>Release</code>) or debugging flags (<code>Debug</code>).</li> <li>CMAKE_INSTALL_PREFIX: The directory where to copy installation files after you built the package in the build folder. After running the install step, the installation directory will contain all executables, libraries and modules built by the CMake package.</li> </ul> <p>You can obtain a list of all pre-defined CMake variables withe flag <code>--help-variable-list</code></p> <pre><code>cmake --help-variable-list\n</code></pre>"},{"location":"configuration/#specifying-the-compilers","title":"Specifying the compilers","text":"<p>In order to build a CMake package, you will need a compiler. If not specified, CMake will look for a compiler on your system and use the first it finds.</p> <p>Warning</p> <p>If multiple compilers are present on the system CMake may find the wrong compiler, without returning any error. This results in errors at building or run time.</p> <p>You can define the compiler by setting an environment variable before configuring the project.  The name of the environment variable will depend on the choice of the compiler. Common variables are <code>CXX</code>,<code>CC</code> and <code>FC</code>, respectively for the <code>C++</code>,<code>C</code> and <code>Fortran</code> languages. For instance for a GNU compiler, one could run</p> <pre><code>export CXX=g++\nexport CC=gcc\nexport FC=gfortran\n</code></pre> <p>before cmake.</p> <p>Alternatively, you can specify the compilers by setting the appropriate CMake variables:</p> <pre><code> cmake ${CMAKE_PACKAGE_DIRECTORY} -DCMAKE_Fortran_COMPILER=gfortran -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++\n</code></pre> <p>Exercise</p> <p>Try to build the windtunnel CMake package contained in <code>demos/wind_tunnel</code>.You will need to define some variables in order to successfully build the package.</p>"},{"location":"getting_started/","title":"Getting started","text":"<p>In order to build a CMake package you first need to install CMake itself.</p>"},{"location":"getting_started/#getting-cmake","title":"Getting CMake","text":"<p>You can install CMake from several package managers. For instance, using <code>apt</code> on Ubuntu:</p> <pre><code>sudo apt install cmake\n</code></pre> <p>On computing clusters CMake is usually already centrally installed. Like on the ARCHER2 machine, loading the centrally installed module is done with:</p> <pre><code>module load cmake\n</code></pre>"},{"location":"getting_started/#compiling-a-cmake-package","title":"Compiling a CMake package","text":"<p>Compiling a CMake package requires three steps:</p> <ul> <li>A Configuration step</li> <li>A Build step</li> <li>An install step</li> </ul>"},{"location":"getting_started/#configuration","title":"Configuration","text":"<p>First you need to create a build directory. It will be populated with temporary build files, such as object files and internal CMake configuration files. You then need to go inside that newly created directory as the following commands will need to be run from within it:</p> <pre><code>mkdir $BUILD_DIRECTORY \ncd $BUILD_DIRECTORY\n</code></pre> <p>You also need to tell CMake to look for compilers, check for dependencies and find where libraries are stored on your system. Let us assume you wish to compile the source code in <code>$CMAKE_PACKAGE_DIRECTORY</code> and that the resulting binaries should be installed in <code>$INSTALL_DIR_PACKAGE</code>. From the build directory run:</p> <pre><code>cmake $CMAKE_PACKAGE_DIRECTORY -DCMAKE_INSTALL_PREFIX=$INSTALL_DIR_PACKAGE .\n</code></pre> <p>This will generate a build system in the build directory. On UNIX based systems, the default build system is <code>Makefile</code>. Alternatively, you can run CMake from any directory, by specifying the the source and build directory respectively with the <code>-S</code> and <code>-B</code> flag.</p> <pre><code>cmake -S $CMAKE_PACKAGE_DIRECTORY -B $BUILD_DIRECTORY\n</code></pre>"},{"location":"getting_started/#build","title":"Build","text":"<p>Upon successful completion of the configuration step CMake will output a <code>Makefile</code> in your build directory. In order to compile the package you can type</p> <pre><code>make\n</code></pre> <p>If you wish to see some more verbose output, including the compilation commands being executed type</p> <pre><code>make VERBOSE=1\n</code></pre> <p>After a successful build, the binary files will be saved somewhere in the build directory. Alternatively, you can use</p> <pre><code>cmake --build .\n</code></pre>"},{"location":"getting_started/#install","title":"Install","text":"<p>Once all the executable and libraries have been generated, these need to be copied to the installation directory you specified during the configuration phase. You can copy the binaries in your specified install directory by running:</p> <pre><code>make install\n</code></pre> <p>Alternatively, you can run</p> <pre><code>cmake --build . --target install\n</code></pre>"},{"location":"getting_started/#tests","title":"Tests","text":"<p>CMake contains a mechanism to run tests. This can be useful to test that the package was successfully installed. If tests have been defined by the CMake package developers, from the build directory you can type</p> <pre><code>ctest \n</code></pre> <p>This command will run all the tests. If a test fails it will print out an error message.</p> <p>Exercise</p> <p>Try to build the hello world CMake package contained in <code>demos/hello_world_cmake</code>.</p>"},{"location":"introduction/","title":"Introduction","text":"<p>CMake is a programming language and a framework designed to simplify the process of building large applications.</p>"},{"location":"introduction/#the-compilation-process","title":"The compilation process","text":"<p>When you compile a package you usually want to obtain an executable binary file from a collection of human-readable text files. This process often requires complex steps and some of these also require invoking a compiler and linking with external libraries. These complex instructions can be encoded in a build system. On an UNIX system, a common one is <code>Makefile</code>.</p> <p><code>Makefile</code> is able to describe all the steps in the compilation process but is not aware of the user's system configuration. Hence, packages distributed with a plain <code>Makefile</code> often require users to manually specify the location of compilers and libraries, by editing the <code>Makefile</code> or some custom configuration file. This process is time consuming, not standardised and error prone.</p> <p></p>  Compilation process using a Makefile. The user needs to manually specify the paths to compilers and libraries required during the build process"},{"location":"introduction/#how-does-cmake-help","title":"How does CMake help ?","text":"<p>CMake automates the processes of defining compilers and libraries on the system. It also automates the process of finding the locations of the packages required by the build process. Once CMake has figured out the configuration of the user system, it generates a build system. Then the user runs the build system in order to generate the executable.</p> <p></p>  Compilation process using CMake. The user may have to provide options to the CMake build script provided by the package developer. Once configured the framework will generate a build system, often a Makefile describing all the build steps on the target system."},{"location":"introduction/#what-is-cmake","title":"What is CMake ?","text":"<ul> <li>A programming langauge: CMake is a domain specific language to describe the steps necessary to build a software package.</li> <li>A build system generator: CMake is not a build system. Instead it generates a build system.</li> <li>An abstraction of the build process: As a CMake package developer, you need to specify the source files, the libraries you need to link to and other project properties. CMake is responsible for working out file dependencies and the shell commands required to compile, link and install package binaries on the target system.</li> </ul>"},{"location":"introduction/#main-features-of-cmake","title":"Main features of CMake","text":"<ul> <li>Portability: CMake is able to generate a variety of build systems for many platforms (including Linux, Windows and Mac). For Unix systems, Makefile is the default build system.</li> <li>Out of source build: intermediary build files are generated in a build directory, separate from the source directory. This prevents polluting the source directory and allows multiple builds from the same source code directory.</li> </ul>"},{"location":"introduction/#drawbacks-of-cmake","title":"Drawbacks of CMake","text":"<ul> <li>Troubleshooting: when configuration fails, issues can be difficult to diagnose and fix.</li> <li>Versioning: CMake has changed between different versions and default behaviours have as well. This can make the build succeed with a CMake version but fail with an other version.</li> <li>Development practices: good practices in the community have changed over time. Older packages may still use unsafe or deprecated practices.</li> </ul>"},{"location":"resources/","title":"Resources","text":"<p>Below you can find some further online resources to learn CMake:</p> <ul> <li>https://cliutils.gitlab.io/modern-cmake/</li> <li>https://cmake.org/cmake/help/latest/</li> <li>https://coderefinery.github.io/cmake-workshop/testing/</li> <li>https://enccs.github.io/cmake-workshop/cmake-syntax/</li> </ul>"},{"location":"structure/","title":"Writing a CMake package","text":"<p>Occasionally, in order to build a code, you need to modify a CMake package. Learning to recognise the different components of a CMake package is useful even if you are not a CMake package developer. This page gives a brief overview of how to write a CMake package.</p>"},{"location":"structure/#structure-of-a-cmake-project","title":"Structure of a CMake project","text":"<p>A CMake package needs to contain at least one <code>CMakeLists.txt</code> file. This file describes the CMake package using the CMake programming language. The CMake programming language is a complete programming language in which one can define variables, conditionals, loops and all the features you would expect from a modern programming language.</p>"},{"location":"structure/#project-definition","title":"Project definition","text":"<p>You start writing a <code>CMakeLists.txt</code> file by defining the minimum supported version of cmake and which compiler languages are supported. Then you need to define the project with the <code>project( ... )</code> function. This function takes as arguments the name of the project and accepts optionally a list of programming languages included in the project.</p> <pre><code>cmake_minimum_required( VERSION 3.2 )\nproject( wind_tunnel LANGUAGES FORTRAN CUDA )\n</code></pre>"},{"location":"structure/#targets","title":"Targets","text":"<p>A target defines an object to be built by CMake. A target may be either an executable or a library. You can define a property on a target to control how the target is built. For instance, you can compile and link flags, external libraries and the location of source files by defining the appropriate properties for the target.</p> <p></p>  The output executable my_exec is defined as a target. In order to build the target, you can set the target properties `source_files` and `link_libraries`. A property can contain a list of elements and those elements can be other targets. <p>To create an executable target you can use the <code>add_executable</code> function, which takes as argument the name of the new target to be created: <pre><code>add_executable( my_exec )\n</code></pre> You can also specify the location of the source files needed to build the executable by setting the <code>sources</code> property with the <code>target_sources</code> function:</p> <pre><code>target_sources( my_exec PRIVATE source1.f90 source2.f90 )\n</code></pre> <p>The function accepts as the first argument the name of the target. The following argument is a declaration of how the property should be propagated to other targets that depend on the target <code>my_exec</code>. Valid accessor values are:</p> <ul> <li>PUBLIC: the property gets forwarded to targets which depend on the current target.</li> <li>PRIVATE: the property is used for the current target and is forwarded to other targets which depend on the current target</li> <li>INTERFACE: the property is not used to build the current target, but is forwarded to other targets which depend on the current target</li> </ul> <p>In this case, you only need the source files to build the current target, so you may declare the property as private. The declaration is followed by a list of filenames. In order to create an executable, you often need to link with external libraries in the linking phase. You may do so using the <code>target_link_libraries</code> function. This function sets the <code>link_libraries</code> property for a target. If you wish <code>my_exec</code> to use <code>MPI</code> in <code>Fortran</code>, you can use:</p> <pre><code>target_link_libraries( my_exec  MPI::MPI_Fortran )\n</code></pre> <p>Where the first argument is the name of the target and the second one is the name of the external library.</p> <p>You might also need to include external files, such as <code>C/C++</code> header files or <code>Fortran</code> modules. You may do so with the <code>target_include_directories</code> function. This function takes as argument the name of the target, followed by the access specifier and a list of directories. For instance you can include <code>MPI</code> Fortran modules with:</p> <pre><code>target_include_directories( my_exec PUBLIC ${MPI_FORTRAN_DIRS} )\n</code></pre>"},{"location":"structure/#find_package","title":"find_package","text":"<p>This command looks for a specific package. The command will look for instructions on how to find a package by looking for a <code>Find&lt;Packagename&gt;.cmake</code> file. You can specify whether the package is optional or required for a successful build. The command <code>find_package</code> will look for the package in a pre-defined set of directories and will return the first one it finds. If no package is found and the package is marked as required a fatal error will be thrown. If a package is found it will define targets and/or variables which you can use later in your project.</p> <p>Exercise</p> <p>The folder <code>demos/create_a_package</code> contains the source code of a MPI hello world fortran program. It also contains a <code>CMakeLists.txt</code> but it does not define any target. Fill in the CMake code required to build an executable.</p>"},{"location":"structure/#variables","title":"Variables","text":"<p>You can define custom variables in a CMake package using the function <code>set</code>. The function accepts as first argument the name of the variable and as second argument the value of the variable.  For instance, in order to set a variable with name <code>USE_CUDA</code> to the value <code>false</code>:</p> <pre><code>set( USE_CUDA false )\n</code></pre> <p>You can access the value of a variable by prefixing with a <code>$</code> sign. For instance, for the variable defined above the command</p> <pre><code>${USE_CUDA}\n</code></pre> <p>will evaluate to false. CMake variables are usually local in scope to the function that they are defined in. If defined outside of a function, they are local to the subdirectory. Hence, a variable defined in a subfolder will not be accessible from the parent directory.  One exception are variables defined as <code>CACHE</code>. These variables are global variables which can be accessed from anywhere in the project, no matter where they are defined. Additionally, once a cache variable has been set, it will not be changed by successive cmake calls. Cached variables are used for variables that need to be set from the user. A variable can be set as cached by setting a third optional argument to <code>CACHE</code>.  For instance, to set the <code>CMAKE_BUILD_TYPE</code> variable to <code>Release</code> you can use</p> <pre><code>set( CMAKE_BUILD_TYPE Release CACHE )\n</code></pre>"},{"location":"structure/#options","title":"Options","text":"<p>These are logical variables which you can turn on or off at configure time. You can use options to enable compilation of additional components or to provide support for additional parallel paradigms. You can define an option with the <code>option( ...)</code> function, which can accept as arguments the name of the variable to be set, an helper string to provide a human-readable description of the option and the value ON or OFF. For instance, in order to turn on CUDA support, you may use</p> <pre><code>option( USE_CUDA \"Enable using CUDA for optimization\" ON )\n</code></pre>"},{"location":"structure/#include-subdirectories","title":"Include subdirectories","text":"<p>It is good practice to organise your package in different modules. You can place each module in a separate directory. Then you can write a <code>CMakeLists.txt</code> file in each subdirectory describing how to build the corresponding module. You can have an additional <code>CMakeLists.txt</code> in the root folder of your project and add the subdirectories to your main project. You can add sub directories with the <code>add_subdirectory( ... )</code>function. This function takes as argument the location of the sub folder. For instance, if you want to include a <code>src</code> folder in your project you may use </p> <pre><code>add_subdirectory( src )\n</code></pre> <p>Exercise</p> <p>Look at the CMake code for the windtunnel program.</p> <ul> <li>Can you recognise the different sections ?</li> <li>Where is the executable target defined ?</li> <li>Where is the target linked to MPI ?</li> <li>Where is the default build type defined ?</li> </ul>"},{"location":"trouble_shooting/","title":"Trouble shooting","text":""},{"location":"trouble_shooting/#finding-mpi","title":"Finding MPI","text":"<p>Most implementations of MPI come with a compiler wrapper. It is a good practice to provide the CMake compiler wrapper to CMake. CMake will often figure out that the compiler provided is a MPI wrapper, set the <code>MPI_FOUND</code> variable to true and understand that no additional options or flags are required when building the project.</p>"},{"location":"trouble_shooting/#using-find_package","title":"Using find_package","text":"<p>The command <code>find_package</code> can be used to find any package or library the project depends on. It will look for the package in a pre-defined set of directories and will return the first one it finds. If CMake can find a package, it will import new targets which you can later used in your project. You can find a list of packages supported by CMake developers on the main documentation. To obtain a list of supported packages the <code>--help-module-list</code> argument can be used together with filtering for entries that start with \"Find\":</p> <pre><code>cmake --help-module-list | grep \"Find\"\n</code></pre> <p>If CMake cannot find the package and you marked it as required, it will throw a fatal error. In such situation, or if a wrong version is found, you can specify the location of the package by setting the variable <code>&lt;PACKAGE_NAME&gt;_ROOT</code>. CMake will then look for the package in that folder.</p> <p>Warning</p> <p>Be aware that that behaviour of <code>find_package</code> has changed over the years and older versions of CMake use different rules to find packages. For example, some older versions will ignore the <code>&lt;PACKAGE_NAME&gt;_ROOT</code> variable and others will ignore it but print a policy warning.</p>"},{"location":"trouble_shooting/#cmake-policy-warning","title":"Cmake policy warning","text":"<p>Sometimes CMake's output reports the message:</p> <p>Error</p> <p>CMake Warning (dev) at CMakeLists.txt:6 (find_package): Policy CMP0074 is not set: find_package uses _ROOT variables. Run \"cmake --help-policy CMP0074\" for policy details.  Use the cmake_policy command to set the policy and suppress this warning. <p>Environment variable MPI_ROOT is set to:</p> <p>/mnt/lustre/indy2lfs/sw/intel/compilers_and_libraries_2020.4.304/linux/mpi/intel64</p> <p>For compatibility, CMake is ignoring the variable. This warning is for project developers.  Use -Wno-dev to suppress it.</p> <p>This appears when a default behaviour changes between different CMake versions. Whenever a behavioural change is introduced in CMake the old default will be kept for a few versions and the above deprecation warning printed. Package developers can set the new behaviour by setting the corresponding policy to new. Reading the warning and the policy definition might help asses whether the deprecation will affect your build or not.</p>"},{"location":"trouble_shooting/#tracing","title":"Tracing","text":"<p>When debugging a CMake installation, you may find useful to print out the commands being executed by CMake. This is possible by adding to the <code>cmake</code> command the flag <code>--trace-source=${CMAKE_FILE}</code>, where <code>${CMAKE_FILE}</code> is the name of the file containing the CMake code. For instance to debug CMake code contained in the <code>CMakeLists.txt</code> file you can use:</p> <pre><code>cmake --trace-source=CMakeLists.txt \n</code></pre> <p>By adding the flag <code>--trace-expand</code> each variable will be substituted with their current value.</p>"}]}